quit
(into {:a 1 :b 2} {:a 3})
(doc assoc)
(def maps (ref {}))
(def record My [name t])
(defrecord My [name t])
(def update-my [name t]
   )
(defn update-my [my t]
  (My. (:name my) (+ (:t my) t)))
(update-my (My. "a" 1) 1)
(assoc (My. "a" 1) :t 2)
(def maps {})
(assoc maps :abc (update-my (:abc maps) 10))
(doc get)
(use 'goat.core :reload)
(def myfun [] (Thread/sleep 1000))
(defn myfun [] (Thread/sleep 1000))
(myfun)
(instrument-functions! 'user)
(use 'goat.core :reload)
(instrument-functions! 'user)
perf-funs
(keys perf-funs)
(type perf-funs)
(keys @perf-funs)
(get @perf-funs #'user/myfun)
(type (get @perf-funs #'user/myfun))
(FPerf.)
(My.)
(use 'goat.core :reload)
(reset-instrumentation)
@perf-funs
(instrument-function! 'user)
(instrument-functions! 'user)
(get @perf-funs #'user/myfun)
(myfun)
(get @perf-funs #'user/myfun)
(use 'goat.core :reload)
(reset-instrumentation)
(reset-instrumentation!)
(get @perf-funs #'user/myfun)
(instrument-functions! 'user)
(get @perf-funs #'user/myfun)
(myfun)
(get @perf-funs #'user/myfun)
(update-fperf @perf-funs #'user/myfun 1 100)
(add-perf-data #'user/myfun 100)
(get @perf-funs #'user/myfun)
@perf-funs
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(get @perf-funs #'user/myfun)
(use 'goat.core :reload)
(myfun)
(get @perf-funs #'user/myfun)
(get @perf-funs myfun)
(name myfun)
#myfun
(1)
#'myfun
(meta myfun)
(use 'goat.core :reload)
(myfun)
(use 'goat.core :reload)
(myfun)
(use 'goat.core :reload)
(myfun)
~myfun
~'myfun
'~myfun
(use 'goat.core :reload)
(myfun)
(use 'goat.core :reload)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
`myfun
(let [m myfun]
 `m)
(let [m myfun] 
  #'m)
(let [m myfun] #m)
(let [m myfun] 'm)
(let [m myfun] (unquote m))
(let [m myfun] (name m))
(let [m myfun] (class m))
(let [m myfun] (type m))
(let [m myfun] (class m))
(defn fun-name [f]
)
(ns-vars '#user)
(+ 1 2)
(ns-vars #'user)
(ns-map #'user)
(ns-map user)
(ns-map)
(ns-map 'user)
(get (ns-map 'user) myfun)
(get (ns-map 'user) 'user/myfun)
(first (keys (ns-map 'user)))
(type 
(first (keys (ns-map 'user))))
(get (ns-map 'user) 'myfun)
(type (get (ns-map 'user) 'myfun)
)
(get (ns-map 'user) 'myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-function 'user)
(instrument-function #'user)
(instrument-functions! #'user)
(instrument-functions! 'user)
(doc alter-var-root)
(doc var)
(doc 'myfun)
(doc 'user/myfun)
(defn myfun [] (Thread/sleep 100))
(doc 'user/myfun)
(var 'user/myfun)
(doc var-get)
(var-get myfun)
(var-get 'myfun)
(var-get '#myfun)
(var-get #'myfun)
(var #'myfun)
(def f (var-get #'myfun))
(var f)
(var-get f)
(vars)
vars
(find-var 'myfun)
(find-var #'myfun)
(find-var f)
(find-var (var-get f))
(find-var (var f))
(find-var 'f)
(find-var 'user/f)
(find-var 'user/myfun)
(var-get 'f)
(var-get 'myfun)
(var-get '#myfun)
(var-get #'myfun)
(var-get #'f)
(str f)
(str (var-get #'f))
`myfun
(def [l myfun] `l)
(let [l myfun] `l)
(let [l myfun] (var l))
(let [l myfun] (var-get l))
(let [l myfun] (type l))
(let [l myfun] (class l))
(let [l myfun] (var-get l))
(let [l myfun] (var-get (symbol l)))
(let [l myfun] (var-get #'l))
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-function! 'user)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(defn fun-name [fun]
  (symbol (.getName (.-ns fun)) "." (.-sym fun)))
(fun-name myfun)
(fun-name (var-get  myfun))
(doc var-get)
(var myfun)
`(var myfun)
(instrument-functions! 'user)
(use 'goat.core :reload)
quit
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(instrument-functions! 'user)
(doc var)
(var myfun)
myfun
(defn myfun [] (Thread/sleep 10))
(var myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(class myfun)
(myfun)
(class myfun)
(doc find-var)
(use 'goat.core :reload)
(instrument-functions! 'user)
(var-get 'user/myfun)
(var-get (find-var 'user/myfun))
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'robert.hooke)
(def m [])
(add-hook #'m (fn [f & args] (prn "shit") (m)))
(m)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(myfun)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
quit
(defn myfun [] (Thread/sleep 100))
(use 'goat.core :reload)
(instrument-functions! 'user)
(myfun)
(use 'goat.core :reload)
(reset-instrumentation!)
(instrument-functions! 'user)
(myfun)
qui
quit
(use 'goat.core :reload)
(defn myfun [] (Thread/sleep 100))
(instrument-functions! 'user)
(myfun)
(get-fperf 'user/myfun)
@perf-funs
(keys @perf-funs
)
(map type (keys @perf-funs
)
(find-var 'usr/myfun)
(find-var 'user/myfun)
(var-get (find-var 'user/myfun)
)
(use 'goat.core :reload)
(get-fperf 'user/myfun)
(get-fperf 'user.myfun)
(get @perf-funs 'user.myfun)
(def myfun-sym (nth (keys @perf-funs 5)))
(def myfun-sym (nth (keys @perf-funs) 5))
(myfun-sym
)
myfun-sym
(def myfun-sym (nth (keys @perf-funs) 4))
myfun-sym
(keys @perf-funs)
(instrument-functions! 'user)
(keys @perf-funs)
(get @perf-funs 'user.myfun)
(myfun)
(get @perf-funs 'user.myfun)
(myfun)
(get @perf-funs 'user.myfun)
(myfun)
(get @perf-funs 'user.myfun)
quit
(use 'goat.core :reload)
(instrument-functions! 'user)
(map type (keys @perf-funs))
(def t (first (keys @perf-funs))
)
(get-var t)
(find-var t)
t
(doc find-var)
(find-var t)
(find-var @t)
(find-var (str t))
(str t)
(find-var 'user.cdoc)
(find-var 'user/cdoc)
(reset-instrumentation!)
(instrument-functions! 'user)
(def t (first (keys @perf-funs)))
t
quit
(instrument-functions! 'user)
(use 'goat.core :reload)
(instrument-functions! 'user)
(def t (first (keys @perf-funs)))
t
(find-var t)
(type (find-var t))
(namespace (find-var t))
(doc namespace)
(namespace t)
(type (namespace t)
)
(str 'user)
(= (namespace t) (str 'user))
quit
(use 'goat.core :reload)
(instrument-functions! 'user)
(use 'goat.core :reload)
(instrument-functions! 'user)
(def m [^long i])
(defn m [^long i])
quit
(use 'goat.core :reload)
(type (System/currentTimeMillis))
(type (long (System/currentTimeMillis))
)
(use 'goat.core :reload)
(defn myfun [n] (Thread/sleep n))
(instrument-functions! 'user)
(myfun 100)
(get-fperf 'user/myfun)
(reset-instrumentation! 'user)
(use 'goat.core :reload)
(reset-instrumentation! 'user)
(get-fperf 'user/myfun)
(myfun 100)
(get-fperf 'user/myfun)
(myfun 100)
(get-fperf 'user/myfun)
(reset-instrumentation! 'user)
(myfun 100)
(get-fperf 'user/myfun)
(instrument-functions! 'user)
(myfun 100)
(get-fperf 'user/myfun)
(reset-instrumentation!)
(myfun 100)
(get-fperf 'user/myfun)
(clear-perf-data)
quit
(use 'goat.core)
(defn myfun [n] (Thread/sleep n))
(instrument-functions! 'user)
(myfun 100)
(get-fperf 'user/myfun)
(get-fperf-data)
(use 'goat-core :reload)
(use 'goat.core :reload)
(instrument-functions! 'user)
(myfun)
(myfun 100)
(get-fperf-data)
